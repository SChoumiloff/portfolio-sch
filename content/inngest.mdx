---
title: "Inngest, orchestrer et automatiser vos workflows"
publishedAt: "2025-01-09"
summary: "Inngest est une plateforme puissante conÃ§ue pour automatiser vos workflows. Elle peut transformer vos processus mÃ©tier et booster la productivitÃ© de votre Ã©quipe."
keywords: ["inngest", "orchestrer", "automatiser", "workflow", "productivitÃ©"]
descriptionSocials: "ğŸš€ DÃ©couvrez comment utiliser Inngest pour la gestion des tÃ¢ches asynchrones dans vos applications Next.js et Python."
author: "Sacha Choumiloff"
image: "/icon-logo-inngest.png"
keywordsSEO: ["inngest", "workflow automation", "orchestration", "workflow management", "asynchronous workflows", "event-driven architecture", "task automation", "workflow orchestration", "business process automation", "workflow engine", "serverless workflows", "distributed systems", "event processing", "task scheduling", "workflow steps", "error handling", "retry mechanisms", "rate limiting", "concurrency control", "workflow monitoring", "workflow debugging", "workflow testing", "workflow deployment", "workflow scaling", "workflow reliability", "event sourcing", "message queues", "job scheduling", "cron jobs", "background jobs", "task queues", "workflow patterns", "workflow templates", "workflow best practices", "workflow integration", "workflow development", "workflow architecture", "workflow design", "workflow implementation", "workflow optimization", "next.js workflows", "python workflows", "typescript workflows", "fastapi workflows", "resend integration", "email automation", "workflow rollback", "workflow recovery", "workflow monitoring", "workflow analytics", "workflow metrics", "workflow observability", "workflow security", "workflow performance", "workflow scalability", "workflow maintenance", "workflow documentation", "workflow testing", "workflow deployment", "workflow management system", "workflow orchestration platform", "workflow automation tool", "workflow engine comparison", "airflow alternative", "temporal alternative", "perfect alternative", "open source workflow", "cloud workflow", "enterprise workflow", "startup workflow", "modern workflow", "workflow 2024", "workflow solution", "workflow platform", "workflow service", "workflow infrastructure", "workflow architecture", "workflow development", "workflow implementation", "workflow optimization", "workflow best practices", "workflow patterns", "workflow templates", "workflow examples", "workflow tutorials", "workflow guide", "workflow documentation", "workflow case studies", "workflow use cases", "workflow benefits", "workflow features", "workflow comparison", "workflow selection", "workflow evaluation", "workflow adoption", "workflow migration", "workflow integration", "workflow customization", "workflow configuration", "workflow deployment", "workflow monitoring", "workflow maintenance", "workflow support", "workflow community", "workflow ecosystem"]
tags: ["Inngest","workflows asynchrones","orchestrateur","automatisation","processus mÃ©tier","Node.js","Python","Airflow","Temporal","tutoriel workflows"]
readingTime: "15 min"
---

# Inngest : orchestrer et automatiser vos workflows

Il existe dÃ©jÃ  de nombreux orchestrateurs pour automatiser et gÃ©rer efficacement les workflows, tels quâ€™Airflow, Temporal ou encore Perfect.  
Pourtant, **Inngest** est un petit nouveau qui fait beaucoup parler de lui : utilisÃ© par des acteurs majeurs comme **Soundcloud**, **TripAdvisor** ou encore **Resend**, il offre une approche moderne et minimaliste pour concevoir des workflows asynchrones.

## Qui suis-je ?

Je suis **Sacha Choumiloff**, ingÃ©nieur logiciel et entrepreneur. Mon objectif Ã  travers ces articles est de vous prÃ©senter des outils et des techniques qui, je lâ€™espÃ¨re, sauront vous inspirer et vous aider Ã  construire ou amÃ©liorer vos propres projets.

Dans les sections suivantes, nous explorerons :

1. **Les fonctionnalitÃ©s clÃ©s** dâ€™Inngest et comment il se diffÃ©rencie des autres orchestrateurs.  
2. **Des exemples concrets**: implÃ©mentations en Python et TypeScript (Next.js), illustrant comment intÃ©grer Inngest dans des environnements variÃ©s pour orchestrer des workflows asynchrones de maniÃ¨re efficace.
3. **Ses avantages et inconvÃ©nients** pour vous aider Ã  dÃ©terminer si câ€™est la bonne solution pour vos besoins.  

PrÃªt Ã  dÃ©couvrir comment Inngest peut simplifier la conception de vos workflows asynchrones ? Câ€™est parti !

## Quâ€™est-ce que Inngest ?

Inngest est une plateforme [**open source**](https://github.com/inngest/inngest) crÃ©ee en 2021 pour les dÃ©veloppeurs souhaitant rÃ©aliser des applications avec des workflows asynchrones de maniÃ¨re simple et Ã©volutive. Elle remplace les mÃ©canismes traditionnels comme les files dâ€™attente, la gestion dâ€™Ã©tat ou encore la planification, en proposant des fonctions durables, simplifiant le dÃ©veloppement dâ€™applications fiables tout en Ã©liminant le besoin dâ€™une infrastructure complexe. Elle permet Ã©galement de simplifier la stack technique et de combiner en un seul outil des fonctionnalitÃ©s comme la gestion d'Ã©venements, la gestion d'Ã©tat, la planification de tÃ¢ches, et d'autres; RÃ©duisant ainsi le nombre d'outils Ã  connaitre, utiliser et maintenir. 

## Les fonctionnalitÃ©s clÃ©s

Inngest propose un ensemble de fonctionnalitÃ©s puissantes qui permettent de gÃ©rer efficacement les workflows asynchrones. Voici quelques-unes des principales :

![Inngest fct](/inngest-benef.png)

## Comment fonctionne Inngest ? 

Prenons un exemple concret pour illustrer le fonctionnement d'Inngest. Au sein de l'application Analyzeurbiz, plusieurs actions asynchrones sont dÃ©clenchÃ©es par des Ã©vÃ©nements spÃ©cifiques cÃ´tÃ© client (Demande d'analyse SEO d'un Ã©tablissement) ou serveur (Lancement quotidien de la mise Ã  jour des avis). 
1. La logique de ces actions est encapsulÃ©e dans des fonctions dÃ©finies dans le code, enrichies par des dÃ©corateurs Inngest. Ces dÃ©corateurs permettent dâ€™ajouter des fonctionnalitÃ©s supplÃ©mentaires aux fonctions sans modifier leur code dâ€™origine. Nous dÃ©taillerons leur utilisation dans la section suivante.
2. Le client Inngest agit comme un composant intermÃ©diaire qui organise et encapsule la logique fonctionnelle de lâ€™application. Il dÃ©finit des points dâ€™entrÃ©e spÃ©cifiques (comme les endpoints A, B, C), chacun conÃ§u pour rÃ©pondre Ã  un Ã©vÃ©nement ou gÃ©rer une tÃ¢che prÃ©cise. Ces points dâ€™entrÃ©e permettent de recevoir, traiter et rediriger les Ã©vÃ©nements ou actions nÃ©cessaires vers un point central de communication, reprÃ©sentÃ© ici par lâ€™URL https://api.analyzeurbiz.com. Cela garantit une gestion centralisÃ©e et structurÃ©e des flux dâ€™Ã©vÃ©nements, tout en veillant Ã  lâ€™exÃ©cution claire et ordonnÃ©e de chaque tÃ¢che ou processus.
3. Le moteur dâ€™Inngest prend en charge :
    - **Orchestration des workflows** : Inngest sâ€™assure que chaque tÃ¢che (ou fonction) est exÃ©cutÃ©e dans le bon ordre, en fonction des dÃ©pendances dÃ©finies.
    - **DurabilitÃ©** : Les workflows sont persistants, ce qui signifie quâ€™ils peuvent survivre Ã  des interruptions (pannes, redÃ©marrages, etc.).
    - **Planification** : Le moteur gÃ¨re la planification des exÃ©cutions en temps rÃ©el ou diffÃ©rÃ© selon les besoins.
    - **Reprises** : En cas dâ€™Ã©chec, le moteur permet de relancer les workflows Ã  partir de lâ€™Ã©tape Ã©chouÃ©e, sans recommencer tout le processus.
    - **Gestion des erreurs** : Le moteur gÃ¨re les erreurs de maniÃ¨re intelligente, en permettant de relancer les workflows Ã  partir de lâ€™Ã©tape Ã©chouÃ©e, sans recommencer tout le processus.
    - **Gestion des tÃ¢ches CRON** : Le moteur permet de planifier et lancer les tÃ¢ches CRON de maniÃ¨re simple et efficace.
4. Le moteur dâ€™Inngest communique avec lâ€™API AnalyzeUrBiz pour :
    - Transmettre des mises Ã  jour ou des rÃ©sultats des workflows exÃ©cutÃ©s.
    - Recevoir de nouveaux Ã©vÃ©nements ou dÃ©clencheurs.

![Inngest workflow](/inngest-presentation.png)

Ã€ travers ce modÃ¨le, Inngest permet Ã  Analyzeurbiz de gÃ©rer des workflows complexes de maniÃ¨re simple, fiable et Ã©volutive, tout en dÃ©lÃ©guant la gestion des Ã©tats et de lâ€™orchestration au moteur inngest. Ce serveur est similaire Ã  la version de production.

## Le serveur de dÃ©veloppement

Le serveur de dÃ©veloppement est un outil puissant qui permet de dÃ©velopper et tester les fonctions Inngest de maniÃ¨re simple et efficace. Il permet de lancer le serveur Inngest pour le dÃ©veloppement, de tester les fonctions et de visualiser les Ã©vÃ©nements et les rÃ©sultats des workflows exÃ©cutÃ©s.

## Les Ã©vÃ©nements 

Les fonctions inngest sont dÃ©clenchÃ©es au travers d'Ã©vÃ©nements issus de plusieurs sources :

- Depuis l'application qu'on est en train de dÃ©velopper
- Via une tÃ¢che CRON (tous les soirs Ã  22h22)
- Via un Ã©vÃ¨nement webhook

### Pourquoi utiliser des Ã©vÃ¨nements et non des innvocations directes ? 

#### 1- **Le DÃ©clenchement mutiple** : Un mÃªme Ã©vÃ©nement peut activer plusieurs fonctions Inngest simultanÃ©ment.
Lorsquâ€™un utilisateur sâ€™inscrit (user.signup), plusieurs actions doivent Ãªtre exÃ©cutÃ©es : 
    - envoyer un e-mail de bienvenue
    - crÃ©er un profil utilisateur
    - enregistrer lâ€™Ã©vÃ©nement pour des analyses futures

Avec **l'invocation directe**, chaque action doit Ãªtre appelÃ©e explicitement, ce qui complexifie le code et augmente les dÃ©pendances entre les composants.

Avec l'utilisation **d'Ã©vÃ¨nements**, un seule Ã©vÃ©nement (Ã¹ser.signup`) peut dÃ©clencher automatiquement toutes les fonctions nÃ©cessaires. 

#### 2- Synchronisation avancÃ©e : Les Ã©vÃ©nements permettent de synchroniser lâ€™exÃ©cution des fonctions Inngest

Prenons l'exemple d'une fonction qui doit attendre la validation dâ€™un paiement avant de procÃ©der Ã  lâ€™expÃ©dition dâ€™une commande.

Avec **l'invocation directe**, la fonction dâ€™expÃ©dition doit continuellement vÃ©rifier lâ€™Ã©tat du paiement, entraÃ®nant une logique complexe et une utilisation inefficace des ressources.

Avec **l'utilisation d'Ã©vÃ¨nements**, la fonction dâ€™expÃ©dition peut Ãªtre configurÃ©e pour attendre un Ã©vÃ©nement payment.confirmed, garantissant une synchronisation prÃ©cise sans vÃ©rifications rÃ©pÃ©tÃ©es.

#### 3- InteropÃ©rabilitÃ© inter-applications

L'utilisation d'Ã©vÃ¨nements permet de dÃ©coupler les applications, facilitant ainsi la communication entre elles.

Une entreprise utilise plusieurs applications qui doivent rÃ©agir lorsquâ€™un nouveau client est ajoutÃ©.

Avec **l'invocation directe**, chaque application doit implÃ©menter des appels spÃ©cifiques pour interagir avec les autres, augmentant la complexitÃ© et les risques dâ€™erreurs.

Avec **l'utilisation d'Ã©vÃ¨nements**, un Ã©vÃ©nement `new.customer` peut Ãªtre Ã©mis, et toutes les applications concernÃ©es peuvent sâ€™y abonner et rÃ©agir en consÃ©quence

## ContrÃ´le des workflows

Inngest permet au travers un contrÃ´le des workfows avancÃ© au travers des paramÃ¨tres suivants : 

- **La gestion de la concurrence**: est essentielle pour optimiser lâ€™utilisation des ressources informatiques et adapter les charges de travail. Le contrÃ´le de concurrence dâ€™Inngest vous permet de gÃ©rer le nombre dâ€™Ã©tapes exÃ©cutÃ©es simultanÃ©ment.
- **La limitation de dÃ©bit**: elle permet de spÃ©cifier combien dâ€™exÃ©cutions de fonctions peuvent commencer dans une pÃ©riode donnÃ©e. Lorsque la limite est atteinte, les nouvelles exÃ©cutions de fonctions dÃ©passant cette limite seront mises en file dâ€™attente pour une exÃ©cution ultÃ©rieure. La limitation de dÃ©bit fonctionne selon le principe FIFO (*First In First Out*).
- **La limitation du taux de requÃªtes**: impose une limite stricte sur le nombre dâ€™exÃ©cutions de fonctions pouvant dÃ©buter dans une pÃ©riode donnÃ©e. Les Ã©vÃ©nements dÃ©passant cette limite sont ignorÃ©s et ne dÃ©clenchent pas lâ€™exÃ©cution des fonctions, ce qui prÃ©vient une surcharge du systÃ¨me sur une pÃ©riode dÃ©terminÃ©e.
- **La priorisation**: permet dâ€™exÃ©cuter dynamiquement certaines tÃ¢ches avant ou aprÃ¨s dâ€™autres, en fonction de diverses donnÃ©es. Cela vous offre la possibilitÃ© de hiÃ©rarchiser des travaux sans recourir Ã  une file dâ€™attente distincte.

## Diviser un workflow en plusieurs Ã©tapes: Les **steps**

Les steps dâ€™Inngest permettent de structurer un workflow en plusieurs Ã©tapes distinctes et indÃ©pendantes. Cela offre plusieurs avantages :
- **ModularitÃ©** : Chaque Ã©tape peut Ãªtre testÃ©e et exÃ©cutÃ©e sÃ©parÃ©ment.
- **Gestion des Erreurs** : Si une Ã©tape xÃ©choue, Inngest peut automatiquement rÃ©essayer ou reprendre lâ€™exÃ©cution Ã  partir de cette Ã©tape.
- **LisibilitÃ©** : Les workflows deviennent plus faciles Ã  comprendre et Ã  maintenir.
- **Conditions** : Les Ã©tapes peuvent Ãªtre conditionnÃ©es par des Ã©vÃ©nements ou des donnÃ©es, permettant de crÃ©er des workflows adaptatifs.

Il existe plusieurs mÃ©thodes pour crÃ©er des steps : 

**step.run()** :  C'est la mÃ©thode la plus courante. Elle permet d'Ã©xecuter une fonction qui sera automatiquement retentÃ©e en cas d'Ã©chec.

**step.sleep()** : Permet de mettre en pause le workflow pendant un certain temps avant de reprendre l'exÃ©cution. 
-  J'envoi un mail a un utilisateur (*step.run*)
-  Je mets en pause le workflow pendant deux jours (*step.sleep*)
-  Je vÃ©rifie si il a rÃ©pondu a mon mail (*step.run*)
-  Si oui, je gÃ©nÃ¨re une rÃ©ponse automatique (*step.run*) 
-  Si non, je le relance (*step.run*)  

**step.waitForEvent()** : N'executera l'Ã©tape que lorsque l'Ã©vÃ©nement spÃ©cifiÃ© sera dÃ©clenchÃ©.
- Envoi dâ€™un e-mail de confirmation (*step.run*)
- On attend la rÃ©ception dâ€™une approbation (*step.waitForEvent*)
    - Pendant cette Ã©tape, le workflow est en pause et nâ€™avance pas tant que lâ€™Ã©vÃ©nement attendu nâ€™est pas reÃ§u.
- On finalise le processus de confirmation.

**step.invoke()** : Permet d'invoquer une autre fonction inngest dans le workflow. Elle permet de rÃ©utiliser des fonctions dÃ©jÃ  Ã©crites.

## Gestion des erreurs et retry

La gestion des erreurs est un aspect crucial dans tout systÃ¨me distribuÃ©. Inngest simplifie considÃ©rablement cette problÃ©matique en intÃ©grant des mÃ©canismes de reprise intelligents :
1. Gestion automatique des erreurs
- DÃ©tection automatique des Ã©checs
- Reprise intelligente des fonctions en erreur
- Conservation de l'Ã©tat entre les tentatives
2. Types d'erreurs gÃ©rÃ©es
- Timeouts rÃ©seau
- Pannes temporaires de services
- Conflits de base de donnÃ©es
- Erreurs de connexion API
3. BÃ©nÃ©fices
- Robustesse accrue des workflows
- RÃ©duction du code de gestion d'erreurs
- Meilleure rÃ©silience des applications

Cette approche "retry-first" d'Inngest vous permet de vous concentrer sur votre logique mÃ©tier plutÃ´t que sur la gestion des cas d'erreur, tout en garantissant la fiabilitÃ© de vos workflows.

**Reprises automatiques** : Par dÃ©faut, Inngest rÃ©exÃ©cute une fonction ou une Ã©tape jusquâ€™Ã  quatre fois aprÃ¨s une tentative initiale infructueuse, totalisant ainsi cinq tentatives dâ€™exÃ©cution. Cela assure une rÃ©silience face aux erreurs transitoires telles que les dÃ©lais dâ€™attente rÃ©seau ou les indisponibilitÃ©s temporaires de services.

**Configurer la reprise sur erreur**: Vous pouvez personnaliser le nombre de reprises pour chaque fonction afin de les adapter Ã  des cas dâ€™utilisation spÃ©cifiques. DÃ©finir le nombre de reprises Ã  zÃ©ro dÃ©sactive entiÃ¨rement les reprises automatiques.

**Reprises au niveau des steps inngest** : Les fonctions peuvent Ãªtre dÃ©composÃ©es en plusieurs steps, chacune disposant de sa propre logique de reprise. En cas dâ€™Ã©chec dâ€™une Ã©tape particuliÃ¨re, seule cette Ã©tape est retentÃ©e, permettant une gestion des erreurs plus fine et une rÃ©cupÃ©ration plus efficace.

**Erreurs non rÃ©essayables** : Dans les situations oÃ¹ une erreur est permanente (par exemple, une entrÃ©e invalide), vous pouvez dÃ©clencher une erreur non rÃ©essayable pour empÃªcher toute nouvelle tentative et provoquer immÃ©diatement lâ€™Ã©chec de lâ€™Ã©tape ou de la fonction concernÃ©e.

**Personnalisation du timing des reprises** : Inngest utilise par dÃ©faut une stratÃ©gie de reprise avec dÃ©lai exponentiel et variation alÃ©atoire. Cependant, il est possible de spÃ©cifier des timings de reprise prÃ©cis, par exemple en respectant un en-tÃªte â€˜Retry-Afterâ€™ dâ€™une API externe, afin de mieux gÃ©rer les limitations de taux et dâ€™Ã©viter des reprises inutiles.

## Le Rollback

Le rollback est une fonctionnalitÃ© qui permet de revenir Ã  l'Ã©tat prÃ©cÃ©dent un workflow en cas d'Ã©chec. Voyons rapidement ce que propose Inngest : 

Inngest offre des mÃ©canismes de rollback au niveau des steps de vos workflows. Lorsquâ€™un step Ã©choue aprÃ¨s avoir Ã©puisÃ© toutes ses tentatives de rÃ©exÃ©cution, une StepError est gÃ©nÃ©rÃ©e. Cela vous permet de gÃ©rer les Ã©checs de chaque Ã©tape de maniÃ¨re granulaire et de rÃ©cupÃ©rer Ã©lÃ©gamment des erreurs sans compromettre lâ€™ensemble du workflow.

## Installation d'Inngest

Passons maintenant Ã  la pratique. CommenÃ§ons par l'installation d'Inngest dans un projet Next.js. Nous verrons ensuite comment l'utiliser dans un projet Python.

### Dans une application Next.js

Installation du SDK de Inngest; Permettant de crÃ©er les fonctions Inngest

```bash
    npm install inngest
```

Installation et lancement du serveur de dÃ©veloppement Inngest; Permettant de lancer le serveur Inngest pour le dÃ©veloppement

```bash
    npx inngest-cli@latest dev
```

CrÃ©ation d'un singleton Inngest

Dans le fichier `src/inngest/client.ts`

```Typescript
    import { Inngest } from "inngest";

    export const inngest = new Inngest({ id: "analyzeurbiz" });
```

Nous avons maintenant Ã  dÃ©finir la route inngest dans le fichier `src/app/api/inngest/route.ts` pour permettre Ã  Inngest de communiquer avec l'application.

```ts
    import { serve } from "inngest/next";
    import { inngest } from "../../../inngest/client";

    export const { GET, POST, PUT } = serve({
        client: inngest,
        functions: [
            
        ],
    });
```

[AccÃ©der Ã  l'interface de dÃ©veloppement](http://localhost:8288)

### Dans un projet Python

CrÃ©ation d'un environnement virtuel et installation des dÃ©pendances

```bash
    python -m venv .venv && source .venv/bin/activate   #crÃ©ation et activation d'un virtual env
    pip install fastapi inngest uvicorn
```

CrÃ©ation du singleton Inngest

Dans le fichier `inngest/client.py`

```python
    import inngest
    import logging

    class InngestClientSingleton:
        _instance = None

        def __new__(cls, app_id: str):
            if cls._instance is None:
                cls._instance = super(InngestClientSingleton, cls).__new__(cls)
                cls._instance.client = inngest.Inngest(app_id=app_id, 
                                                       logger=logging.getLogger("uvicorn"))
            return cls._instance

        def get_client(self):
            return self.client
```

CrÃ©ation d'un fichier `main.py` (Api FastAPI pour la communication avec le moteur Inngest)

```python
    from fastapi import FastAPIfrom fastapi import FastAPI
    from inngest.client import InngestClientSingleton

    app = FastAPI()

    app_id = "analyzeurbiz"
    singleton = InngestClientSingleton(app_id)
    inngest_client = singleton.get_client()

    inngest.fast_api.serve(app, inngest_client, [my_function])
```


lancement du serveur de dÃ©veloppement Inngest (deux maniÃ¨re diffÃ©rentes)

1. En utilisant node et l'application Next.js

```bash
    npx inngest-cli@latest dev -u http://127.0.0.1:8000/api/inngest --no-discovery
```

2. En utilisant docker

```bash
    docker run -p 8288:8288 inngest/inngest \
        inngest dev -u http://host.docker.internal:8000/api/inngest --no-discovery
```

[AccÃ©der Ã  l'interface de dÃ©veloppement](http://localhost:8288)

## Exemple concrets : 

### Envoi d'un mail avec Resend et Inngest: 

Au sein d'une application comme Analyzeurbiz, la communication asynchrone avec les utilisateurs se fait principalement par le biais d'emails. l'envoi de ces derniers peut parfois Ãªtre bloquant (l'application doit attendre l'envoi final du mail pour reprendre son fonctionnement). Ici l'approche synchrone est donc Ã  Ã©viter pour favoriser l'expÃ©rience utilisateur. On va donc crÃ©er une fonction inngest qui va nous permettre d'envoyer un mail de contact suite Ã  la soummission d'un formulaire. 

![Inngest mail](/inngest-workflow-1.png)

#### En typescript avec le framework Next.js

Dans le fichier `src/inngest/functions.ts` on dÃ©finit la mÃ©thode sendEmail en utilisant le client inngest.

```typescript
    import { inngest } from '@/inngest/client';
    import { Resend } from '@resend/node';

    const resend = new Resend('your_resend_api_key');

    export const sendEmail = inngest.createFunction(
    { name: 'Send Email' },
    { event: 'app/send_email' },
    async ({ event, step }) => {
        const emailData = {
        from: 'sender@example.com',
        to: 'recipient@example.com',
        subject: 'Hello from Inngest and Resend',
        html: '<h1>Welcome!</h1><p>This is a test email.</p>',
        };
        const response = await resend.emails.send(emailData);
        console.log('Email sent:', response);
    }
    );
```

On ajoute cette fonction Ã  la liste des fonctions Ã  exÃ©cuter dans le fichier `src/app/api/inngest/route.ts`. Cette Ã©tape est nÃ©cessaire pour que le serveur de dÃ©veloppement Inngest connaitre la fonction et l'Ã©xecuter.

```typescript
    import { serve } from "inngest/next";
    import { inngest } from "@/inngest/client";

    export const { GET, POST, PUT } = serve({
        client: inngest,
        functions: [
            sendEmail
        ],
    });
```

#### En Python 

Dans le fichier `main.py`

```python

    import logging
    from fastapi import FastAPI
    import inngest
    import inngest.fast_api
    from resend import Resend

    resend_client = Resend(api_key="your_resend_api_key")

    @inngest_client.create_function(
        fn_id="send_email_function",
        trigger=inngest.TriggerEvent(event="app/send_email"),
    )
    async def send_email(ctx: inngest.Context, step: inngest.Step) -> str:
        email_data = {
            "from": "sender@example.com",
            "to": ["recipient@example.com"],
            "subject": "Hello from Inngest and Resend",
            "html": "<h1>Welcome!</h1><p>This is a test email.</p>",
        }
        response = resend_client.send_email(**email_data)
        ctx.logger.info(f"Email sent: {response}")
        return "Email sent successfully"
```

On utiliser le dÃ©corateur `@inngest_client.create_function` pour crÃ©er la fonction inngest. Ce dÃ©corateur permet d'ajouter de nombreux paramÃ¨tres que nous verrons dans les prochains cas d'usage.

### Gestion d'un workflow multiSteps

Le workflow que nous allons mettre en place consiste Ã  enrichir des donnÃ©es utilisateur avec des informations gÃ©nÃ©rÃ©es par une IA (ex. : rÃ©sumÃ©, tags, etc.) et Ã  stocker ces informations dans une base de donnÃ©es.

![Inngest workflow](/inngest-workflow-2.png)

On verra au fur et Ã  mesure de la mise en place de ce workflow les diffÃ©rentes notions prÃ©cÃ©demments Ã©voquÃ©s.

##### En typescript avec le framework Next.js

Dans le fichier `src/inngest/functions.ts` on dÃ©finit la mÃ©thode enrichUserData en utilisant le client inngest.

```typescript
    import { inngest } from "inngest";

    export const enrichUserData = inngest.createFunction(
        { name: "Enrich User Data" },
        { event: "user.signup" },
        async ({ step, event }) => {
            const formData = await step.run("Retrieve Form Data", async () => {
                return getFormData(event.data.formId);
            });

            const enrichedData = await step.run("Call AI API", async () => {
                return callAIAPI(formData);
            });

            const updatedData = await step.run("Update Data with New Info", async () => {
                return enrichWithAdditionalInfo(enrichedData);
            });

            await step.run("Save to Database", async () => {
                return saveToDatabase(updatedData);
            });
        }
    );
```

Ajout de la fonction Ã  la liste des fonctions Ã  exÃ©cuter dans le fichier `src/app/api/inngest/route.ts`.

```typescript
    import { serve } from "inngest/next";
    import { inngest } from "@/inngest/client";

    export const { GET, POST, PUT } = serve({
        client: inngest,
        functions: [
            enrichUserData
        ],
    });
```

##### En Python

```python
@inngest.function(name="Enrich User Data")
async def enrich_user_data(event):
    form_data = await step_run("Retrieve Form Data", get_form_data, event["data"]["form_id"])
    enriched_data = await step_run("Call AI API", call_ai_api, form_data)
    updated_data = await step_run("Update Data with New Info", enrich_with_additional_info, enriched_data)
    await step_run("Save to Database", save_to_database, updated_data)
```

Ajoutons maintenant une limitation pour respecter les quotas de notre API AI. L'api est limitÃ©e Ã  10 requÃªtes par minute. 

##### En typescript

```ts
const throttledCallAIAPI = inngest.rateLimit(callAIAPI, {
  max: 10, // ->  Maximum de 10 appels
  window: "1s", // -> Par seconde
});

export const enrichUserData = inngest.createFunction(
  { name: "Enrich User Data" },
  { event: "user.signup" },
  async ({ step, event }) => {
    const formData = await step.run("Retrieve Form Data", async () => {
      return getFormData(event.data.formId);
    });

    const enrichedData = await step.run("Call AI API", async () => {
      return throttledCallAIAPI(formData);
    });

    const updatedData = await step.run("Update Data with New Info", async () => {
      return enrichWithAdditionalInfo(enrichedData);
    });

    await step.run("Save to Database", async () => {
      return saveToDatabase(updatedData);
    });
  }
);
```

##### En Python

```python
async def throttled_call_ai_api(data):
    await inngest.rate_limit(
        max_calls=10,
        window="1s"
    )
    return await call_ai_api(data)

@inngest.function(name="Enrich User Data")
async def enrich_user_data(event):
    form_data = await step_run("Retrieve Form Data", get_form_data, event["data"]["form_id"])
    enriched_data = await step_run("Call AI API", throttled_call_ai_api, form_data)
    updated_data = await step_run("Update Data with New Info", enrich_with_additional_info, enriched_data)
    await step_run("Save to Database", save_to_database, updated_data)
```

Ajoutons la gestion automatique des erreurs avec des retries exponentiels. Les retries exponentiels sont une stratÃ©gie de gestion des erreurs oÃ¹ le dÃ©lai entre chaque tentative augmente exponentiellement. Par exemple :
- 1Ã¨re retry : 1 seconde
- 2Ã¨me retry : 2 secondes 
- 3Ã¨me retry : 4 secondes
- 4Ã¨me retry : 8 secondes

ImplÃ©mentons cette stratÃ©gie dans notre workflow :

##### En typescript

```ts
    export const enrichUserData = inngest.createFunction(
        { name: "Enrich User Data" },
        { event: "user.signup" },
        async ({ step, event }) => {
            const formData = await step.run("Retrieve Form Data", async () => {
                return getFormData(event.data.formId);
            });

            const enrichedData = await step.run("Call AI API", async () => {
                return callAIAPI(formData);
            }, { retry: { attempts: 3, backoff: "exponential" } });

            const updatedData = await step.run("Update Data with New Info", async () => {
                return enrichWithAdditionalInfo(enrichedData);
            });

            await step.run("Save to Database", async () => {
                return saveToDatabase(updatedData);
            });
        }
    );
```

##### En Python

```python
    @inngest.function(name="Enrich User Data")
    async def enrich_user_data(event):
        form_data = await step_run("Retrieve Form Data", get_form_data, event["data"]["form_id"])
        enriched_data = await step_run("Call AI API", call_ai_api, form_data, retries=3, backoff="exponential")
        updated_data = await step_run("Update Data with New Info", enrich_with_additional_info, enriched_data)
        await step_run("Save to Database", save_to_database, updated_data)
```

IntÃ©grons un rollback pour annuler les modifications si l'Ã©tape "Call AI API" Ã©choue.

##### En typescript

```ts
    export const enrichUserData = inngest.createFunction(
        { name: "Enrich User Data" },
        { event: "user.signup" },
        async ({ step, event }) => {
            const formData = await step.run("Retrieve Form Data", async () => {
                return getFormData(event.data.formId);
            });

            const enrichedData = await step
            .run("Call AI API", async () => {
                const aiResponse = await callAIAPI(formData);
                // Sauvegarder la rÃ©ponse brute de l'API pour pouvoir la restaurer si nÃ©cessaire
                await saveRawAIResponse(event.data.userId, aiResponse);
                return aiResponse;
            }, { 
                retry: { 
                attempts: 3, 
                backoff: "exponential" 
                } 
            })
            .catch((err) =>
                step.run("Rollback AI API Call", async () => {
                // En cas d'Ã©chec, on supprime la rÃ©ponse brute sauvegardÃ©e
                await deleteRawAIResponse(event.data.userId);
                // On peut aussi logger l'erreur ou effectuer d'autres actions de nettoyage
                    console.error("AI API call failed:", err);
                }),
            );

            const updatedData = await step.run("Update Data with New Info", async () => {
                return enrichWithAdditionalInfo(enrichedData);
            });

            await step.run("Save to Database", async () => {
                return saveToDatabase(updatedData);
            });
        }
    );
```

##### En Python

Cette fonctionnalitÃ© n'est pas encore disponible dans le SDK Python. Je mettrai Ã  jour ce post dÃ¨s que ce sera le cas.

On pourrait encore ajouter beaucoup de fonctionnalitÃ©s Ã  notre workflow. Par exemple : 
- Attendre l'event `user.first_login_after_signup` pour envoyer un email de bienvenue par exemple en utilisant le step `step.waitForEvent()`
- DÃ©tection du niveau dâ€™abonnement : Identifier le niveau dâ€™abonnement (premium, standard, gratuit) Ã  partir des donnÃ©es utilisateur ou dâ€™une base de donnÃ©es.
    - **Attribution de prioritÃ©** : Assigner une prioritÃ© numÃ©rique (ex. : 1 pour premium, 2 pour standard, 3 pour gratuit) pour classer les tÃ¢ches.
    - **Ordonnancement dynamique** : Traiter les tÃ¢ches par prioritÃ©, en exÃ©cutant dâ€™abord celles des utilisateurs premium.
    - **Throttling par catÃ©gorie** : Limiter les appels API par utilisateur selon leur abonnement (ex. : 20/min pour premium, 10/min pour standard, 5/min pour gratuit).
    - **Retry personnalisÃ©** : Ajuster les tentatives de rÃ©essai et les dÃ©lais selon la prioritÃ© (plus de tentatives pour les abonnÃ©s premium).
    - **Gestion Ã©quitable des ressources** : Suspendre ou ralentir les tÃ¢ches des utilisateurs de niveau infÃ©rieur en cas de surcharge.

## Inngest: ses avantages et ses inconvÃ©nients :

**Avantages** :
- **IntÃ©gration simplifiÃ©e** : Les SDK dâ€™Inngest sâ€™intÃ¨grent facilement dans les bases de code existantes, permettant aux dÃ©veloppeurs de crÃ©er rapidement des fonctions fiables sans gÃ©rer lâ€™infrastructure sous-jacente. ï¿¼
- **FlexibilitÃ©** : Inngest est adaptÃ© Ã  divers cas dâ€™utilisation, notamment les workflows durables, les files dâ€™attente, les tÃ¢ches en arriÃ¨re-plan et les travaux planifiÃ©s ou cron. ï¿¼
- **ScalabilitÃ©** : La plateforme est conÃ§ue pour Ã©voluer avec les besoins des applications modernes, assurant une gestion efficace des processus Ã  grande Ã©chelle. ï¿¼

**InconvÃ©nients** :
- **Courbe dâ€™apprentissage** : Bien quâ€™Inngest simplifie lâ€™orchestration des workflows, les dÃ©veloppeurs novices peuvent nÃ©cessiter un temps dâ€™adaptation pour maÃ®triser pleinement ses fonctionnalitÃ©s.
- **DÃ©pendance Ã  la plateforme** : Lâ€™adoption dâ€™Inngest peut entraÃ®ner une dÃ©pendance vis-Ã -vis de cet outil pour la gestion des workflows, ce qui pourrait poser des dÃ©fis en cas de migration vers une autre solution.

En somme, Inngest est une solution puissante pour les Ã©quipes de dÃ©veloppement souhaitant orchestrer et automatiser des workflows asynchrones de maniÃ¨re efficace, avec une intÃ©gration simplifiÃ©e et une flexibilitÃ© adaptÃ©e aux besoins des applications modernes.

Dans un prochain article, je vous prÃ©senterai le **Workflow Kit dâ€™Inngest**, un ensemble dâ€™outils open source qui facilite la crÃ©ation de workflows personnalisÃ©s. Ce kit offre des actions prÃ©dÃ©finies pour le moteur de workflow et des composants React prÃªts Ã  lâ€™emploi pour construire votre interface dâ€™Ã©dition de workflows.

