---
title: "Zod : Validez vos donn√©es avec √©l√©gance et simplicit√©"
summary: "D√©couvrez comment utiliser Zod pour valider vos donn√©es de mani√®re √©l√©gante et simple dans vos applications Next.js."
descriptionSocials: "üöÄ Zod : Validez vos donn√©es avec √©l√©gance et simplicit√© dans Next.js !"
keywords: ["Zod", "Validation", "Next.js", "TypeScript", "Data Validation", "Type Safety"]
author: "Sacha Choumiloff"
publishedAt: "2025-02-04"
image: "/zod-logo.png"
keywordsSEO: [
    "zod validation",
    "typescript schema validation",
    "next.js data validation",
    "zod typescript",
    "form validation next.js",
    "type safety typescript",
    "zod schema validation",
    "runtime type checking",
    "data validation javascript",
    "zod tutorial",
    "typescript validation library",
    "next.js form validation",
    "zod best practices",
    "type inference typescript",
    "schema validation next.js",
    "zod vs joi",
    "typescript data validation",
    "server side validation",
    "api validation next.js",
    "zod examples"
]
tags: ["Next.js", "TypeScript", "Validation", "Zod"]
readingTime: "5 min"
---

# Zod : Validez vos donn√©es avec √©l√©gance et simplicit√©

> - "Est-ce que mon utilisateur a bien rempli tous les champs ?"
> - "Cette API me renvoie-t-elle vraiment les donn√©es au bon format ?"
> - "Comment √™tre s√ªr que mes donn√©es sont conformes avant de les enregistrer en base ?"

Si ces questions vous hantent r√©guli√®rement, vous n'√™tes pas seul. La validation des donn√©es est souvent per√ßue comme la partie fastidieuse du d√©veloppement, celle qu'on reporte toujours √† plus tard... jusqu'√† ce qu'un bug en production nous rappelle son importance cruciale.

Je suis **Sacha Choumiloff**, ing√©nieur logiciel et entrepreneur, et aujourd'hui nous allons explorer Zod, une biblioth√®que facilitant la validation des donn√©es. Fini le temps des validations approximatives ou des v√©rifications de types qui disparaissent √† l'ex√©cution !

Imaginez un monde o√π votre IDE sait exactement √† quoi ressemblent vos donn√©es, o√π vos validations sont aussi √©l√©gantes que votre code, et o√π TypeScript et l'ex√©cution travaillent main dans la main pour garantir la fiabilit√© de vos applications. Ce monde existe, et il s'appelle Zod.

Dans cet article, nous allons explorer ensemble les cas d'usage pratiques de Zod que j'utilise quotidiennement dans mes applications Next.js. De la validation simple des formulaires √† la s√©curisation de vos API et "server functions", vous d√©couvrirez comment cette biblioth√®que peut devenir votre meilleure alli√©e pour une validation des donn√©es facile et intuitive.

## Qu'est-ce que Zod ?

Zod est une biblioth√®que de validation de sch√©mas TypeScript simple et puissante. Contrairement √† d'autres solutions, Zod a √©t√© con√ßu d√®s le d√©part pour TypeScript, ce qui signifie que vous obtenez une inf√©rence de types compl√®te et une s√©curit√© de bout en bout.

### Les points forts de Zod

- **Validation runtime ET statique** : Zod v√©rifie vos donn√©es √† l'ex√©cution tout en fournissant des types TypeScript pr√©cis
- **Zero d√©pendances** : L√©ger et performant, Zod ne p√®se que ~15kb minifi√©
- **Inf√©rence de types automatique** : Plus besoin de d√©finir vos types manuellement, Zod les inf√®re √† partir de vos sch√©mas
- **API intuitive** : Une syntaxe fluide et chainable qui rend la validation agr√©able √† √©crire

## Installation

Commen√ßons par le plus simple :

```bash
npm install zod
# ou
yarn add zod
# ou
pnpm add zod
```

## Les bases, mais en pratique

### Validation de formulaires

Voici un exemple que j'utilise quotidiennement pour les formulaires d'inscription :

```typescript
const signupSchema = z.object({
  email: z.string()
    .email("Nope, cet email n'est pas valide")
    .min(1, "L'email est requis"),
  password: z.string()
    .min(8, "Minimum 8 caract√®res")
    .regex(/[A-Z]/, "Au moins une majuscule")
    .regex(/[0-9]/, "Au moins un chiffre"),
  confirmPassword: z.string()
}).refine(
  data => data.password === data.confirmPassword,
  { message: "Les mots de passe ne correspondent pas" }
);
```

üîç **En action** : [Testez le formulaire en direct](https://dataelevation.dev/example/zod?tab=form)

**O√π j'utilise √ßa** : Sur mon dernier projet SaaS, ce sch√©ma :
- Valide le formulaire d'inscription c√¥t√© client
- Re-valide les donn√©es c√¥t√© serveur (oui, toujours valider c√¥t√© serveur)
- G√©n√®re automatiquement les types TypeScript pour mon API
- Me fait gagner un temps fou en debugging

> üí° Pour une exp√©rience optimale avec les formulaires, je recommande d'utiliser Zod avec [React Hook Form](https://react-hook-form.com/) et les composants de [shadcn/ui](https://ui.shadcn.com/docs/components/form) qui s'int√®grent parfaitement ensemble.

> üí° Je r√©commande aussi fortement l'outil [Shadcn Form builder]("https://shadcn-form-build.vercel.app/playground") avec lequel je construit la quasi totalit√© de mes formulaires. 
### Validation d'API

Si vous pensez que les donn√©es d'une API tierce sont fiables, d√©trompez-vous. Les APIs peuvent :
- Renvoyer des donn√©es manquantes ou dans un format inattendu
- Changer leur structure de r√©ponse sans pr√©venir
- Avoir des bugs temporaires qui affectent le format des donn√©es

Voici comment je me prot√®ge avec Zod :

```typescript
// D√©finition du sch√©ma de validation
const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
  company: z.object({
    name: z.string(),
    catchPhrase: z.string()
  })
});

// Exemple d'utilisation avec fetch
async function fetchUser(id: number) {
  try {
    const response = await fetch(`https://api.example.com/users/${id}`);
    const data = await response.json();
    
    // Validation des donn√©es avec Zod
    const validatedUser = userSchema.parse(data);
    return validatedUser; // Les donn√©es sont maintenant typ√©es et valid√©es ‚ú®
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Gestion sp√©cifique des erreurs de validation
      console.error('Donn√©es invalides:', error.errors);
    }
    throw error;
  }
}

// Le type User est automatiquement inf√©r√© du sch√©ma
type User = z.infer<typeof userSchema>;
```

Si l'API renvoie des donn√©es non conformes, Zod l√®vera une erreur d√©taill√©e :
```typescript
// Exemple de r√©ponse invalide
const invalidData = {
  id: "123", // Devrait √™tre un number
  name: null, // Devrait √™tre une string
  // email manquant
  company: {
    name: "ACME"
    // catchPhrase manquante
  }
};
// Zod g√©n√©rera une erreur avec des messages pr√©cis pour chaque probl√®me
```

üîç **En action** : [Testez la validation d'API](https://dataelevation.dev/example/zod?tab=api)

**O√π j'utilise √ßa** : 
- Pour tous mes appels √† des APIs tierces (Stripe, GitHub, etc.)
- Pour valider les webhooks entrants
- Pour les communications entre mon front et mon back
- Pour √™tre s√ªr que mes types TypeScript sont respect√©s √† l'ex√©cution

### Structures r√©cursives (pour les donn√©es qui s'imbriquent)

Les menus, les commentaires, les cat√©gories... On a tous eu affaire √† des donn√©es imbriqu√©es. Voici comment Zod g√®re √ßa √©l√©gamment :

```typescript
const commentSchema: z.ZodType<any> = z.lazy(() =>
  z.object({
    id: z.number(),
    author: z.string(),
    content: z.string(),
    createdAt: z.string().datetime(),
    replies: z.array(commentSchema).default([]),
  })
);
```

üîç **En action** : [Testez les structures r√©cursives](https://dataelevation.dev/example/zod?tab=recursive)

**O√π j'utilise √ßa** : 
- Pour la validation des commentaires imbriqu√©s sur mon blog
- Pour la gestion des menus dynamiques multi-niveaux
- Pour les arbres de cat√©gories de produits
- Pour valider des JSON complexes

### Transformations (parce que les utilisateurs sont cr√©atifs)

Les utilisateurs trouvent toujours des fa√ßons cr√©atives d'entrer des donn√©es. Voici comment je g√®re √ßa :

```typescript
const priceSchema = z.string()
  .transform((str) => {
    // Nettoie "12,99 ‚Ç¨", "12.99$", etc.
    const cleaned = str.replace(/[^\d.,]/g, "").replace(",", ".");
    const number = parseFloat(cleaned);
    if (isNaN(number)) throw new Error("Prix invalide");
    return number;
  })
  .pipe(z.number().positive("Le prix doit √™tre positif"));

const tagsSchema = z.string()
  .transform(str => str.split(",")
    .map(s => s.trim())
    .filter(Boolean)
  )
  .pipe(z.array(z.string()).min(1, "Au moins un tag requis"));
```

üîç **En action** : [Testez les transformations](https://dataelevation.dev/example/zod?tab=transform)

**O√π j'utilise √ßa** : 
- Pour nettoyer les prix saisis par les utilisateurs
- Pour normaliser les tags et cat√©gories
- Pour convertir les dates entre diff√©rents formats
- Pour standardiser les num√©ros de t√©l√©phone

## Cas d'usage avanc√©s

### Validation contextuelle

Parfois, la validation d'un champ d√©pend d'un autre. Voici comment je g√®re la mise √† jour de mot de passe :

```typescript
const UpdateUserSchema = z.object({
  password: z.string().optional(),
  passwordConfirm: z.string().optional(),
  currentPassword: z.string().optional(),
}).refine((data) => {
  if (data.password) {
    return data.password === data.passwordConfirm;
  }
  return true;
}, {
  message: "Les mots de passe ne correspondent pas",
  path: ["passwordConfirm"],
}).refine((data) => {
  if (data.password) {
    return !!data.currentPassword;
  }
  return true;
}, {
  message: "Mot de passe actuel requis pour le changement",
  path: ["currentPassword"],
});
```

### Gestion des diff√©rents formats de r√©ponse API

Souvent, une API peut renvoyer des r√©ponses dans diff√©rents formats selon le contexte. Par exemple, en cas de succ√®s, vous recevez vos donn√©es, mais en cas d'erreur, vous recevez un message d'erreur. Zod permet de g√©rer √©l√©gamment ces cas avec les "unions discrimin√©es".

```typescript
// D√©finition du format de r√©ponse API
const ApiResponse = z.discriminatedUnion("status", [
  // Format en cas de succ√®s
  z.object({
    status: z.literal("success"),
    data: z.object({
      user: z.object({
        id: z.number(),
        name: z.string(),
        email: z.string().email()
      })
    }),
  }),
  // Format en cas d'erreur
  z.object({
    status: z.literal("error"),
    error: z.object({
      code: z.string(),
      message: z.string(),
    }),
  }),
]);

// Exemple d'utilisation
async function fetchUserData(userId: number) {
  const response = await fetch(`/api/users/${userId}`);
  const data = await response.json();
  
  // Validation avec Zod
  const result = ApiResponse.parse(data);
  
  // TypeScript sait automatiquement quel format utiliser gr√¢ce au status
  if (result.status === "success") {
    // result.data est accessible ici
    console.log(result.data.user.name);
  } else {
    // result.error est accessible ici
    console.error(`Erreur ${result.error.code}: ${result.error.message}`);
  }
}
```

Cette approche offre plusieurs avantages :
- TypeScript sait exactement quelles propri√©t√©s sont disponibles selon le status
- La validation garantit que toutes les donn√©es requises sont pr√©sentes
- Plus besoin de v√©rifications manuelles des propri√©t√©s
- Gestion √©l√©gante des cas d'erreur

üîç **En action** : [Testez la gestion des r√©ponses API](https://dataelevation.dev/example/zod?tab=discriminated)

## Int√©gration avec Next.js

L'un des plus grands avantages de Zod dans un projet Next.js est sa capacit√© √† servir de couche de validation unique entre le frontend et le backend. Dans une architecture moderne, particuli√®rement dans un monorepo, Zod devient un excellent outil pour d√©finir vos DTOs (Data Transfer Objects) une seule fois et les r√©utiliser partout.

### Server Actions : Validation Full-Stack

Imaginez un formulaire de cr√©ation d'article de blog. Avec Zod, vous d√©finissez un seul sch√©ma qui sera utilis√© √† la fois c√¥t√© client pour la validation instantan√©e et c√¥t√© serveur pour la s√©curit√© :

```typescript
// shared/schemas/post.ts
import { z } from "zod";

export const postSchema = z.object({
  title: z.string()
    .min(3, "Le titre doit faire au moins 3 caract√®res")
    .max(100, "Le titre est trop long"),
  content: z.string()
    .min(50, "L'article doit faire au moins 50 caract√®res"),
  tags: z.array(z.string()).min(1, "Ajoutez au moins un tag"),
});

// Type inf√©r√© automatiquement, utilisable c√¥t√© client et serveur
export type Post = z.infer<typeof postSchema>;
```

```typescript
// app/posts/create/action.ts
'use server'

import { postSchema } from '@/shared/schemas/post';

export async function createPost(formData: FormData) {
  // Validation c√¥t√© serveur
  const validated = postSchema.parse({
    title: formData.get("title"),
    content: formData.get("content"),
    tags: formData.get("tags")?.toString().split(','),
  });
  
  // Les donn√©es sont maintenant typ√©es et valid√©es ‚ú®
  await db.posts.create({ data: validated });
}
```

```typescript
// app/posts/create/page.tsx
'use client'

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { postSchema, type Post } from '@/shared/schemas/post';
import { createPost } from './action';

export default function CreatePostPage() {
  const form = useForm<Post>({
    resolver: zodResolver(postSchema), // Validation c√¥t√© client
  });
  
  // ...
}
```

### Route Handlers : APIs Typesafe

Pour vos APIs, Zod permet de cr√©er des endpoints robustes avec une validation pr√©cise des param√®tres. Particuli√®rement utile dans un contexte de monorepo o√π les types sont partag√©s entre le client et le serveur :

```typescript
// shared/schemas/api.ts
import { z } from "zod";

export const paginationSchema = z.object({
  page: z.string().transform(Number).pipe(z.number().positive()),
  limit: z.string().transform(Number).pipe(z.number().min(1).max(100)),
  sort: z.enum(["asc", "desc"]).default("desc"),
});

export type PaginationParams = z.infer<typeof paginationSchema>;
```

```typescript
// app/api/posts/route.ts
import { paginationSchema } from '@/shared/schemas/api';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const validated = paginationSchema.parse(Object.fromEntries(searchParams));
    
    const posts = await db.posts.findMany({
      skip: (validated.page - 1) * validated.limit,
      take: validated.limit,
      orderBy: { createdAt: validated.sort },
    });
    
    return Response.json({ success: true, data: posts });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json({ 
        success: false, 
        errors: error.errors 
      }, { status: 400 });
    }
    return Response.json({ success: false }, { status: 500 });
  }
}
```

Cette approche pr√©sente plusieurs avantages :
- **DRY (Don't Repeat Yourself)** : Un seul sch√©ma pour la validation client et serveur
- **Type-safety** : TypeScript conna√Æt exactement la forme de vos donn√©es
- **Maintenance simplifi√©e** : Modifiez le sch√©ma √† un seul endroit
- **S√©curit√© renforc√©e** : Validation syst√©matique c√¥t√© serveur
- **Meilleure DX** : Autocompl√©tion et d√©tection d'erreurs dans votre IDE

## Conclusion

Zod n'est pas juste une autre biblioth√®que de validation. C'est un outil qui :
- Rend la validation des donn√©es agr√©able (si, si)
- Unifie la validation runtime et le typage statique
- Nous fait gagner un temps pr√©cieux en debugging
- Nous permet de dormir tranquille en production

Si vous en avez marre de d√©bugger des erreurs de validation ou de maintenir des types et des validations s√©par√©s, donnez une chance √† Zod.

Les exemples interactifs de cet article sont disponibles [ici](https://dataelevation.dev/example/zod) pour que vous puissiez exp√©rimenter par vous-m√™me.

